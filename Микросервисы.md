## Книга Микросервисы. Крис Ричардсон.
Книга в бумажном варианте уже полтора года у меня. Прочитал ее полностью примерно год назад, когда работал на должности девопс инженера.
Так как сейчас акцент у меня перешел на разработку(вместе со сменой должности на бэкенд разработчика) - решил перечитать ее заново. Законспектировать.

## Глава 3. Межпроцессорное взаимодействие(IPC).
### Можно выделить основные стили.
#### Один к одному:
*Запрос/ответ.* Клиент отправляет запрос серверу и ждем ответа. Может даже блокироваться на время ожидания. Жестко связывает сервисы  
*Асинхронный запрос/ответ.* Клиент отправляет запрос к серверу, а сервис отвечает асинхронно. Клиент не блокируется, так как сервер может отвечать долго.
*Однонаправленные уведомления.* Клиент отправляет запрос серверу и не ждет ответа.
#### Один ко многим
*Издатель/подписчик.* Клиент публикует сообщение с уведомлением. Все заинтересесованные(подписавшиеся) сервисы получат его.
*Издатель/асинхронные ответы.* Клиент публикует сообщение с уведомлением и ждет некоторое время ответа от заинтересованных сервисов.

### Описание API. Развивающееся API.
API first!  
Это означает, что мы сначала проектируем API. Обсуждаем его со всеми, кому предстоит его реализовывать. Договариваемся на берегу. Это превентивная мера от тех ситуаций, когда команды(скажем бэка и фронта) одновременно реализуют свои части, а потом не могут их заставить работать друг с другом.  
API имеет свойство развиваться, поэтому должно проектироваться с учетом изменений. Для версионирования можно использовать спецификацию семантического версионирования(semver). MAJOR.MINOR.PATCH.

### Форматы сообщений
Суть IPC состоит в обмене сообщениями, которые обычно содержат данные. Разделим их на две категории.  
*Текстовые.* Примерами являются JSON, XML. Что-то человекочитаемое. Недостатки: сообщения получаются довольно объемными, накладные расходы на разбор данных.  
*Двоичные.* Примеры: Protocol buffers, Avro. Для обмена машинами. Оба варианта используют IDL для описания стрктуры сообщений. Затем компилятор генерирует код их сериализации/десериализации. Мы обязаны начинать с проектирования API!

### 3.2 Remote Procedure Invocation(RPI)
Ссылка на источник https://microservices.io/patterns/communication-style/rpi.html  
Взаимодействие на основе удаленного вызова процедур. Примерами реализации данного механизма являются REST и gRPC.
#### REST.
Считается своего рода стандартом де-факто, но при этом имеет и свои минусы.
Почти всегда задействует механизм HTTP и его методы(GET, POST, PUT...)  
##### Существует интересная модель зрелости REST.  
*Уровень 0.* POST на один эндпойнт с указанным действием и параметрами.  
*Уровень 1.* Поддержка концепции ресурса. POST с указанным действием и параметрами.  
*Уровень 2.* Использование HTTP команд. GET для извлечения, POST для создания, PUT для обновления. Можем кешировать GET запросы.  
*Уровень 3.* Это HATEOAS. Основеная суть в том, что возвращаемый ресурс также содержит ссылки для выполнения некоторых действий над собой.  
Посмотрел свои сервисы.. Уровень 2. Не выше, ни ниже. Интересно было бы реализовать HATEOAS.

#### OpenAPI Specification.
И его популярная реализация, точнее даже из нее эта спецификация и пошла  
*Swagger* штука очень полезная и удобная. Активно пользуюсь в ежедневной работе, использовал генераторы кода по спецификации из gradle.
https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin

#### Плюсы..
*Простой и привычный*  
*Легко тестировать из браузера или CLI через curl*  
*Стиль запрос/ответ*  
*Не нуждается в промежуточном брокере*  
*Легко настроить брандмауэр*  
#### ...и минусы REST
*Только стиль запрос/ответ*  
*Снижена степень доступности, никакого буфера. Клиент и сервер общаются напрямую*  
*Надо знать URLы сервисов*  
*Сложность извлечения нескольких связанных ресурсов*  
*Сложность привязки нескольких команд обновления*  

### gRPS
Двоичный формат сообщений, обмен через HTTP/2. Написание начинается с описания API через IDL на основе Protocol Buffers. Компилятор ProtoBuff для многих языков.  
Помимо стиля Запрос/Ответ умеет возвращать поток сообщений клиенту. Также и клиент может послать поток сообщений серверу.  
Имеет маркеры, которые позволяют извлекать только нужные поля, игнорируя ненужные.
#### Плюсы..
*Легко проектировать API с разными вариантами обновлений*  
*Очень компактный и быстрый*  
*Поддержка двунаправленных потоков*  
*Совместимость между клиентами и сервисами на разных языках*  
#### ...и минусы gRPC
*Сложнее работать с ним со стороны JavaScript*  
*Старье не умеет в HTTP/2*  

### Сравним gRPC и REST
Оба синхронные и страдают от проблем с частичным отказом. А так как два брата-акробата, со своими плюсами и минусами.

