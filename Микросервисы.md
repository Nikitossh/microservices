Книга Микросервисы. Крис Ричардсон.
Книга в бумажном варианте уже полтора года у меня. Прочитал ее полностью примерно год назад, когда работал на должности девопс инженера.
Так как сейчас акцент у меня перешел на разработку(вместе со сменой должности на бэкенд разработчика) - решил перечитать ее заново. Законспектировать.

## Глава 3. Межпроцессорное взаимодействие(IPC).
### Можно выделить основные стили.
#### Один к одному:
*Запрос/ответ.* Клиент отправляет запрос серверу и ждем ответа. Может даже блокироваться на время ожидания. Жестко связывает сервисы  
*Асинхронный запрос/ответ.* Клиент отправляет запрос к серверу, а сервис отвечает асинхронно. Клиент не блокируется, так как сервер может отвечать долго.
*Однонаправленные уведомления.* Клиент отправляет запрос серверу и не ждет ответа.
#### Один ко многим
*Издатель/подписчик.* Клиент публикует сообщение с уведомлением. Все заинтересесованные(подписавшиеся) сервисы получат его.
*Издатель/асинхронные ответы.* Клиент публикует сообщение с уведомлением и ждет некоторое время ответа от заинтересованных сервисов.

### Описание API. Развивающееся API.
API first!  
Это означает, что мы сначала проектируем API. Обсуждаем его со всеми, кому предстоит его реализовывать. Договариваемся на берегу. Это превентивная мера от тех ситуаций, когда команды(скажем бэка и фронта) одновременно реализуют свои части, а потом не могут их заставить работать друг с другом.  
API имеет свойство развиваться, поэтому должно проектироваться с учетом изменений. Для версионирования можно использовать спецификацию семантического версионирования(semver). MAJOR.MINOR.PATCH.

### Форматы сообщений
Суть IPC состоит в обмене сообщениями, которые обычно содержат данные. Разделим их на две категории.  
*Текстовые.* Примерами являются JSON, XML. Что-то человекочитаемое. Недостатки: сообщения получаются довольно объемными, накладные расходы на разбор данных.
*Двоичные.* Примеры: Protocol buffers, Avro. Для обмена машинами. Оба варианта используют IDL для описания стрктуры сообщений. Затем компилятор генерирует код их сериализации/десериализации. Мы обязаны начинать с проектирования API!
